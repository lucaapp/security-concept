(badge:static_badge_gen)=
# Generation of Static Badges

A static {term}`Badge` is a small key fob with a QR code printed on one side and a {term}`badge serial number` on the flip side.
It provides an alternative to the {ref}`smartphone based Check-In <process:guest_checkin>` for less tech-savvy {term}`Guest`s.
The QR code for Badges are generated by a {term}`Trusted 3rd Party` and manufactured in bulk by a print shop.
Prior to the first {term}`Check-In` {term}`Guest`s must personalize their Badge with their {term}`Contact Data` using the {term}`Badge Personalization Frontend`.

This chapter describes how the {term}`Badge`s are generated.
Subsequent chapters describe how they are {ref}`personalized<badge:personalization>` and {ref}`used for check-in<badge:check_in>`.

## Overview

```{panels}
Participants
^^^
* {term}`Trusted 3rd Party`
* {term}`Luca Server`

---

Components/Assets
^^^
* {term}`Badge`
* {term}`Badge Generator`

---

Preconditions
^^^
* the {term}`Luca Server` is equipped with a {term}`badge keypair` and a {term}`badge attestation keypair`
* the {term}`Trusted 3rd Party` is ready to use the {term}`Badge Generator`
  * possesses the required Luca API token [^api_token]
  * received the public key of a valid {term}`badge keypair`

---

Postconditions
^^^
* one or more new {term}`Badge`s are generated and registered in the {term}`Luca Server`
```

## Secrets

The following {ref}`secrets <secrets>` are involved in this process:

``````{list-table}
:header-rows: 1
:widths: 1 2 2
:name: Badge Generation Secrets

* - Secret
  - Use / Purpose
  - Location

* - {term}`badge serial number`
  - A random seed to derive the {term}`Badge`'s intrinsic secrets required to both encrypt and associate {term}`Contact Data` and perform {term}`Check-In`s
  - Defined by the {term}`Badge Generator` and printed onto the flip side of the {term}`Badge`.
    Entered into the {term}`Badge Personalization Frontend` to associate {term}`Contact Data` to a {term}`Badge`.
* - {term}`data secret`, {term}`data encryption key`, {term}`data authentication key`, {term}`tracing secret`
  - Those secrets are required for the encryption of {term}`Contact Data` and performing {term}`Check-In`s at _luca_ locations. They are derived from the before-mentioned {term}`badge serial number`.
  - Transiently known to the {term}`Badge Generator`. Later re-derived by the {term}`Badge Personalization Frontend` for encrypting/associating {term}`Contact Data`.
* - `guest keypair`
  - Used to sign the encrypted {term}`contact data reference` on the badge and (during {ref}`badge:personalization`) to authenticate the owner of the Badge.
    This keypair is the Badge-equivalent of the {term}`guest keypair` held by the {term}`Guest App`.
  - The private key is transiently known to the {term}`Badge Generator` as it is derived from the {term}`badge serial number`.
    Later it is re-derived by the {term}`Badge Personalization Frontend` for authenticating the {term}`Contact Data`.
    The public key is stored on the {term}`Luca Server`.
* - {term}`badge keypair`
  - Used to encrypt the {term}`contact data reference` while generating a {term}`Badge`.
  - The public key is obtained from the {term}`Luca Server` [^hdskp_signature]. The private key is known to all {term}`Health Department`s.
* - {term}`badge attestation keypair`
  - Used to sign freshly registered {term}`Badge`s for later validation by the {term}`Scanner Frontend`.
  - The private key is kept in the {term}`Luca Server` for a below-described remote attestation workflow. The {term}`Scanner Frontend` can access the associated public key for validation.
``````

[^hdskp_signature]: The provided public key of the {term}`badge keypair` is signed by a {term}`Health Department` using their {term}`HDSKP`. This signature is provided by the {term}`Luca Server` along with said public key.

## Process

The {term}`Badge Generator` software creates each {term}`Badge` by randomly choosing a 56-bit serial number.
All cryptographic assets and the associated {term}`user ID` for the generated {term}`Badge` are then derived from this initial seed (aka. the {term}`badge serial number`).
The newly generated {term}`Badge` is then registered with the {term}`Luca Server` via an authenticated API request [^api_token].
In response, the {term}`Luca Server` creates a remote attestation signature for the badge using its {term}`badge attestation keypair`.
Eventually, the relevant information is encoded into a QR code and printed on a plastic key fob along with the initially generated serial number.

[^api_token]: For specific tasks the Luca API requires special authentication via a so-called "Bearer token". Further details about the authentication mechanism of the {term}`Luca Server` are beyond the scope of this chapter.

The {term}`Badge Generator` runs the following algorithm to generate a {term}`Badge`:

```{margin} Badge Keypair Generation
To create a badge-specific keypair, the given buffer (`level_one[32:64]`) is interpreted as a private EC point.
The associated public key is derived to form an EC key pair.
In the extremely unlikely event that the big-integer value in the buffer is greater than the EC group's order, the underlying entropy value cannot be used as a badge serial number and is skipped.
The described logic is left out of the pseudo-code for simplicity.
```

```{code} python
# pseudocode

# generate random bytes and use argon2id to derive initial keying material
entropy = random_bytes(7)
seed    = argon2id(entropy, salt="da3ae5ecd280924e",
                   length=16, memorySize=32MiB, iterations=11, parallelism=1)

# generate key material that should be available via the Badge's serial number only
level_one     = HKDF-HMAC-SHA256(seed, length=64,
                                 context="badge_crypto_assets",
                                 salt="")
data_secret   = level_one[0:16]
tracing_seed  = level_one[16:32]
guest_keypair = level_one[32:64]

# generate additional key material that needs to be available to a Scanner Frontend scanning the Badge
level_two              = HKDF-HMAC-SHA256(tracing_seed, length=48,
                                          context="badge_tracing_assets",
                                          salt="")
user_id                = toUuid4(level_two[0:16])
badge_verification_key = level_two[16:32]
tracing_secret         = level_two[32:48]

# encrypt a 'blanco' Contact Data Reference using the badge keypair's public key
iv                   = guest_keypair.public # public key bits truncated to 16 bytes
ephemeral_keys       = newSecp256r1Keypair() # for DLIES with the badge keypair public key
dh_key               = ECDH(ephemeral_keys.private, badge_keypair.public)
enc_key              = HMAC-SHA256(data=dhKey, key=iv) # truncated to 16 bytes
enc_contact_data_ref = AES-128-CTR(user_id || data_secret, enc_key, iv)

# sign the public Badge data with the guest_keypair
signature = sign(guest_keypair.private, user_id || enc_contact_data_ref)

# register the Badge with the Luca Server and receive an
# attestation of the new Badge using the Badge Attestation Key in response
attestation_signature = httpPOST("/api/v3/users/badge",
                                 {
                                    "userId":    user_id,
                                    "publicKey": guest_keypair.public,
                                    "data":      enc_contact_data_ref
                                    "signature": signature
                                 })
```

### QR code and Serial Number Contents

The {term}`Badge`'s QR code is then constructed by concatenating the following data:

* badge revision (currently `0x04`)
* device type (`0x02` for "Badge")
* {term}`badge keypair` ID (1 byte identifier of the {term}`badge keypair` used to encrypt the {term}`contact data reference`)
* `tracing_seed`
* `enc_contact_data_ref`
* `attestation_signature` (in IEEE 1363 format)
* `badge_ephemeral_public_key` (`ephemeral_keys.public` from above)
* checksum (SHA-256 of all the previous data truncated to 4 bytes)

The created data buffer is then encoded using [the Z85 encoding](https://rfc.zeromq.org/spec/32/) and printed onto a plastic key fob in the form of a QR code.
Along with the QR code each {term}`Badge` features its associated {term}`badge serial number` that is the random `entropy` value encoded in [base32crockford](https://www.crockford.com/base32.html) and split into four digit groups (e.g. `LUCA-1337-COOL`).

### Rationale of Generated and Exposed Secrets

The Badge secret derivation is split into three steps:

1. *Hardening against brute force attacks on the short 56-bit serial number.*
   Ensured by employing the password hash algorithm `argon2id`.
   See {ref}`the security considerations <badge:static_badge_gen:considerations>` for a discussion on the chosen tuning parameters.

2. *Derivation of 'secret' values that only the owner of the Badge should have access to.*
   The derive those values one needs to know the {term}`badge serial number` with the exception of the `tracing_seed` which is exposed in plain in the Badge's QR code.
   Secret values are required to {ref}`personalize the Badge<badge:personalization>` or perform contact tracing with it.

3. *Derivation of 'public' values that are exposed in the QR code.*
   These values are revealed in the QR code and allow the {term}`Scanner Frontend` to perform a {term}`Check-In` in the name of the Badge's owner.

All public values revealed on the printed key fob are discussed below.

#### "badge revision" and "device type"

Those are technical values needed by the {term}`Scanner Frontend` to distinguish a {term}`Badge` from a {term}`Guest App` (device type) and allow for schema updates (badge revision) of the described Badge process.

#### {term}`badge serial number`

The Badge's owner can use the badge serial number printed on their key fob for two things:

1. Personalize the Badge by associating their {term}`Contact Data` with the Badge. For further details see {ref}`badge:personalization`.
2. Facilitate a {ref}`contact tracing <process:tracing>` by revealing the Badge's serial number to the {term}`Health Department`

In both cases, either the {term}`Badge Personalization Frontend` or the {term}`Health Department Frontend` will re-derive all necessary secrets from the badge serial number for the desired use case.

#### {term}`badge keypair` ID and `attestation_signature`

The {term}`badge keypair` ID identifies the badge keypair that the {term}`Luca Server` used to sign the badge data during the registration.
Using the public key of the matching {term}`badge keypair` the {term}`Scanner Frontend` can check the `attestation_signature` of the scanned {term}`Badge` and determine whether it is valid or not.
See {ref}`the badge Check-In process <badge:check_in>` for further details.

#### `tracing_seed` and Encrypted {term}`contact data reference` (`enc_contact_data_ref`)

Using the `tracing_seed` the {term}`Scanner Frontend` can derive the badge owner's {term}`user ID` and {term}`tracing secret`.
With this information, the {term}`Scanner Frontend` is able to create a valid {term}`Check-In` for the {term}`Badge`'s owner.
See {ref}`the badge Check-In process <badge:check_in>` for further details.

(badge:static_badge_gen:considerations)=
## Security Considerations

### Choice of `argon2id` Parameters

The parameters for the `argon2id` key derivation function  are optimized to maximally slow down a brute-force attack, while not prohibitively inconveniencing users of low-end commodity hardware in the {ref}`Badge Personalization flow<badge:personalization>`.
The specific parameters (`memorySize`: 32MiB, `iterations`: 11, `parallelism`: 1) yield an execution time of around 0.5 seconds using a native implementation of the on high-end consumer hardware and around 2 to 5 seconds using a browser-based JavaScript/WebAssembly implementation on a mid-range to low-end mobile device.

A random but fixed salt is used.
This is not a problem, as `argon2id` is not used for password hashing here but for key derivation from random input data (termed `entropy` above).
